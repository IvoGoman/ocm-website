<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Guides on</title><link>https://ocm.software/docs/guides/</link><description>Recent content in Guides on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 12 Aug 2022 10:36:48 +0100</lastBuildDate><atom:link href="https://ocm.software/docs/guides/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting Started with OCM</title><link>https://ocm.software/docs/guides/getting-started-with-ocm/</link><pubDate>Mon, 13 Mar 2023 09:38:41 +0100</pubDate><guid>https://ocm.software/docs/guides/getting-started-with-ocm/</guid><description>This chapter walks you through some basic steps to get started with OCM concepts and the OCM CLI.
Prerequisites Create a component version Create a component archive Add a local resource Add an image reference Add an image resource Using a resources file Uploading component versions Bundle composed components All in One Display and Examine component versions List component versions List the resources of a component version Download the resources of a component version Download with download handlers Download an image Download an executable Download a full component version Download OCI Artifacts Transport OCM component versions Sign component versions Signing with certificates Signature Verification Prerequisites # To follow the steps described in this section, you will need:</description></item><item><title>Structuring Software with OCM</title><link>https://ocm.software/docs/guides/structuring-software-with-ocm/</link><pubDate>Fri, 12 Aug 2022 10:36:48 +0100</pubDate><guid>https://ocm.software/docs/guides/structuring-software-with-ocm/</guid><description>Introduction Example Helm Charts Input Specification Building the Common Transport Archive Deploying Software Localization Example Updating Components Introduction # In this specification software products are comprised of logical units called components. A component version consists of a set of technical artifacts, e.g. Docker images, Helm charts, binaries, configuration data etc. Such artifacts are called resources in this specification. Resources are usually built from something, e.g. code in a git repo.</description></item><item><title>Deploying Applications with OCM &amp; GitOps</title><link>https://ocm.software/docs/guides/deploying-applications-with-ocm-and-gitops/</link><pubDate>Wed, 23 Nov 2022 10:00:00 +0000</pubDate><guid>https://ocm.software/docs/guides/deploying-applications-with-ocm-and-gitops/</guid><description>Introduction # This tutorial will demonstrate how to get started deploying applications using the Open Component Model &amp;amp; Flux.
In this guide we will leverage Flux and the ocm-controller to deploy an existing component to a Kubernetes cluster. Specifically, we will deploy the phoban.io/podinfo component that contains the resources needed to launch the podinfo application.
Here&amp;rsquo;s a diagram showing what we&amp;rsquo;ll be building:
As you can see we&amp;rsquo;ll add some manifests to a git repository that will be deployed by Flux.</description></item><item><title>Air-gapped GitOps with OCM &amp; Flux</title><link>https://ocm.software/docs/guides/air-gapped-gitops-with-ocm-and-flux/</link><pubDate>Wed, 23 Nov 2022 10:00:00 +0000</pubDate><guid>https://ocm.software/docs/guides/air-gapped-gitops-with-ocm-and-flux/</guid><description>Introduction # In this guide, we will show how the tools provided by OCM make it possible to automate your air-gapped deployments.
Air-gapped can mean different things depending on the context. For this guide, we&amp;rsquo;ll assume it means your deployment artifacts are stored in a private registry protected by the security controls at your organization. Your applications only have access to this private registry and little to no public internet access.</description></item><item><title>GitOps Driven Configuration of OCM Applications</title><link>https://ocm.software/docs/guides/gitops-driven-configuration-of-ocm-applications/</link><pubDate>Wed, 23 Nov 2022 10:00:00 +0000</pubDate><guid>https://ocm.software/docs/guides/gitops-driven-configuration-of-ocm-applications/</guid><description>Introduction # This guide is the final part of our series exploring OCM, the ocm-controller and how to drive GitOps processes using OCM as the source of truth.
Checkout the previous guides if you haven&amp;rsquo;t already:
Deploy Applications with OCM &amp;amp; GitOps Air-gapped GitOps with OCM &amp;amp; Flux In this guide we will pick-up where we left off in the air-gapped example.
We have successfully transferred a component to our private environment and deployed it using the ocm-controller.</description></item><item><title>Input and Access Types</title><link>https://ocm.software/docs/guides/input_and_access/</link><pubDate>Wed, 05 Apr 2023 08:24:35 +0200</pubDate><guid>https://ocm.software/docs/guides/input_and_access/</guid><description>Input and Access Types Input Types binary dir docker dockermulti file helm ociImage spiff utf-8 Access Types git helm npm ociArtifact s3 Input and Access Types # The Open Component Model spec supports multiple methods how to add resources to a component version. There are two different ways how to add content: Input Type and Access Type
An Input type adds content along with the component descriptor and stores it in the same target repository where the component is stored.</description></item><item><title>Best Practices</title><link>https://ocm.software/docs/guides/best-practices-with-ocm/</link><pubDate>Mon, 13 Mar 2023 12:00:26 +0100</pubDate><guid>https://ocm.software/docs/guides/best-practices-with-ocm/</guid><description>This chapter contains guidelines for common scenarios how to work with the Open Component Model.
Separate between Build and Publish Building multi-arch images Using Makefiles Prerequisites Templating the resources Pipeline integration Static and Dynamic Variable Substitution Debugging: Explain the blobs directory Self-contained transport archives CICD integration Separate between Build and Publish # Typical automated builds have access to the complete internet ecosystem. This involves downloading of content required for a build (e.</description></item></channel></rss>