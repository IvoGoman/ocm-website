var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/core-concepts/",title:"Core Concepts",description:"",content:""}),e.add({id:1,href:"/docs/installation/",title:"Installation",description:"",content:""}),e.add({id:2,href:"/docs/getting-started/",title:"Getting Started",description:"",content:""}),e.add({id:3,href:"/docs/contributing/",title:"Contributing",description:"",content:""}),e.add({id:4,href:"/docs/guides/",title:"Guides",description:"",content:""}),e.add({id:5,href:"/docs/help/",title:"Help",description:"Help Doks.",content:""}),e.add({id:6,href:"/docs/help/how-to-update/",title:"How to Update",description:"Regularly update the installed npm packages to keep your Doks website stable, usable, and secure.",content:` ðŸ’¡ Learn more about semantic versioning and advanced range syntax. Check for outdated packages # The npm outdated command will check the registry to see if any (or, specific) installed packages are currently outdated:
npm outdated [[\u0026lt;@scope\u0026gt;/]\u0026lt;pkg\u0026gt; ...] Update packages # The npm update command will update all the packages listed to the latest version (specified by the tag config), respecting semver:
npm update [\u0026lt;pkg\u0026gt;...] `}),e.add({id:7,href:"/docs/help/troubleshooting/",title:"Troubleshooting",description:"Solutions to common problems.",content:`Problems updating npm packages # Delete the ./node_modules folder, and run again:
npm install Problems with cache # Delete the temporary directories:
npm run clean `}),e.add({id:8,href:"/docs/help/faq/",title:"FAQ",description:"Answers to frequently asked questions.",content:`Hyas? # Doks is a Hyas theme build by the creator of Hyas.
Footer notice? # Please keep it in place.
Keyboard shortcuts for search? # focus: Ctrl + / select: â†“ and â†‘ open: Enter close: Esc Other documentation? # Netlify Hugo Can I get support? # Create a topic:
Netlify Community Hugo Forums Doks Discussions Contact the creator? # Send h-enk a message:
Netlify Community Hugo Forums Doks Discussions `}),e.add({id:9,href:"/docs/cli/add/",title:"add",description:"Usage # ocm add [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for add See Also # Sub Commands # ocm add references	â€” add aggregation information to a component version ocm add resources	â€” add resources to a component version ocm add sources	â€” add source information to a component version ",content:"Usage # ocm add [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for add See Also # Sub Commands # ocm add references	â€” add aggregation information to a component version ocm add resources	â€” add resources to a component version ocm add sources	â€” add source information to a component version "}),e.add({id:10,href:"/docs/cli/describe/artefacts/",title:"artefacts",description:"Usage # ocm describe artefacts [\u0026lt;options\u0026gt;] {\u0026lt;artefact-reference\u0026gt;} Description # Describe lists all artefact versions specified, if only a repository is specified all tagged artefacts are listed. Per version a detailed, potentially recursive description is printed. If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax \u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references.",content:`Usage # ocm describe artefacts [\u0026lt;options\u0026gt;] {\u0026lt;artefact-reference\u0026gt;} Description # Describe lists all artefact versions specified, if only a repository is specified all tagged artefacts are listed. Per version a detailed, potentially recursive description is printed.
If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax
\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references.
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.
Using the JSON variant any repository type supported by the linked library can be used:
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry With the option \u0026ndash;output the output mode can be selected. The following modes are supported:
JSON json yaml Options # -h, --help help for artefacts --layerfiles list layer files -o, --output string output mode (JSON, json, yaml) -r, --repo string repository name or spec Examples # \$ ocm describe artefact ghcr.io/mandelsoft/kubelink \$ ocm describe artefact --repo OCIRegistry:ghcr.io mandelsoft/kubelink See Also # ocm describe	â€” Describe artefacts `}),e.add({id:11,href:"/docs/cli/download/artefacts/",title:"artefacts",description:"Usage # ocm download artefacts [\u0026lt;options\u0026gt;] {\u0026lt;artefact\u0026gt;} Description # Download artefacts from an OCI registry. The result is stored in artefact set format, without the repository part The files are named according to the artefact repository name. If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax \u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references.",content:`Usage # ocm download artefacts [\u0026lt;options\u0026gt;] {\u0026lt;artefact\u0026gt;} Description # Download artefacts from an OCI registry. The result is stored in artefact set format, without the repository part
The files are named according to the artefact repository name.
If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax
\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references.
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.
Using the JSON variant any repository type supported by the linked library can be used:
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry The \u0026ndash;type option accepts a file format for the target archive to use. The following formats are supported:
directory tar tgz The default format is directory. Options # -h, --help help for artefacts -O, --outfile string output file or directory -r, --repo string repository name or spec -t, --type string archive format (default \u0026quot;directory\u0026quot;) See Also # ocm download	â€” Download oci artefacts, resources or complete components `}),e.add({id:12,href:"/docs/cli/get/artefacts/",title:"artefacts",description:"Usage # ocm get artefacts [\u0026lt;options\u0026gt;] {\u0026lt;artefact-reference\u0026gt;} Description # Get lists all artefact versions specified, if only a repository is specified all tagged artefacts are listed. If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax \u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references. [\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:",content:`Usage # ocm get artefacts [\u0026lt;options\u0026gt;] {\u0026lt;artefact-reference\u0026gt;} Description # Get lists all artefact versions specified, if only a repository is specified all tagged artefacts are listed.
If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax
\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references.
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.
Using the JSON variant any repository type supported by the linked library can be used:
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry With the option \u0026ndash;closure the complete reference tree of a index is traversed.
With the option \u0026ndash;output the output mode can be selected. The following modes are supported:
JSON json tree wide yaml Options # -a, --attached show attached artefacts -c, --closure follow index nesting -h, --help help for artefacts -o, --output string output mode (JSON, json, tree, wide, yaml) -r, --repo string repository name or spec -s, --sort stringArray sort fields Examples # \$ ocm get artefact ghcr.io/mandelsoft/kubelink \$ ocm get artefact --repo OCIRegistry:ghcr.io mandelsoft/kubelink See Also # ocm get	â€” Get information about artefacts and components `}),e.add({id:13,href:"/docs/cli/transfer/artefacts/",title:"artefacts",description:"Usage # ocm transfer artefacts [\u0026lt;options\u0026gt;] {\u0026lt;artefact-reference\u0026gt;} Description # Transfer OCI artefacts from one registry to another one If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax \u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references. [\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification: [\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.",content:`Usage # ocm transfer artefacts [\u0026lt;options\u0026gt;] {\u0026lt;artefact-reference\u0026gt;} Description # Transfer OCI artefacts from one registry to another one
If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax
\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references.
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.
Using the JSON variant any repository type supported by the linked library can be used:
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry Options # -h, --help help for artefacts -r, --repo string repository name or spec Examples # \$ ocm oci transfer ghcr.io/mandelsoft/kubelink gcr.io See Also # ocm transfer	â€” Transfer artefacts or components `}),e.add({id:14,href:"/docs/cli/bootstrap/",title:"bootstrap",description:"Usage # ocm bootstrap [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for bootstrap See Also # Sub Commands # ocm bootstrap componentversions	â€” bootstrap component version ",content:"Usage # ocm bootstrap [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for bootstrap See Also # Sub Commands # ocm bootstrap componentversions	â€” bootstrap component version "}),e.add({id:15,href:"/docs/cli/clean/cache/",title:"cache",description:"Usage # ocm clean cache [\u0026lt;options\u0026gt;] Description # Cleanup all blobs stored in oci blob cache (if given).\nOptions # -h, --help help for cache Examples # $ ocm clean cache See Also # ocm clean	â€” Cleanup/re-organize elements ",content:"Usage # ocm clean cache [\u0026lt;options\u0026gt;] Description # Cleanup all blobs stored in oci blob cache (if given).\nOptions # -h, --help help for cache Examples # $ ocm clean cache See Also # ocm clean	â€” Cleanup/re-organize elements "}),e.add({id:16,href:"/docs/cli/clean/",title:"clean",description:"Usage # ocm clean [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for clean See Also # Sub Commands # ocm clean cache	â€” cleanup oci blob cache ",content:"Usage # ocm clean [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for clean See Also # Sub Commands # ocm clean cache	â€” cleanup oci blob cache "}),e.add({id:17,href:"/docs/cli/",title:"cli-reference",description:`Introduction # The Open Component Model command line client support the work with OCM artefacts, like Component Archives, Common Transport Archive,
Component Repositories, and component versions.
Additionally it provides some limited support for the docker daemon, OCI artefacts and registries.
It can be used in two ways:
verb/operation first: here the sub commands follow the pattern \u0026lt;verb\u0026gt; \u0026lt;object kind\u0026gt; \u0026lt;arguments\u0026gt; area/kind first: here the area and/or object kind is given first followed by the operation according to the pattern [\u0026lt;area\u0026gt;] \u0026lt;object kind\u0026gt; \u0026lt;verb/operation\u0026gt; \u0026lt;arguments\u0026gt; The command accepts some top level options, they can only be given before the sub commands.`,content:`Introduction # The Open Component Model command line client support the work with OCM artefacts, like Component Archives, Common Transport Archive,
Component Repositories, and component versions.
Additionally it provides some limited support for the docker daemon, OCI artefacts and registries.
It can be used in two ways:
verb/operation first: here the sub commands follow the pattern \u0026lt;verb\u0026gt; \u0026lt;object kind\u0026gt; \u0026lt;arguments\u0026gt; area/kind first: here the area and/or object kind is given first followed by the operation according to the pattern [\u0026lt;area\u0026gt;] \u0026lt;object kind\u0026gt; \u0026lt;verb/operation\u0026gt; \u0026lt;arguments\u0026gt; The command accepts some top level options, they can only be given before the sub commands.
With the option \u0026ndash;cred it is possible to specify arbitrary credentials for various environments on the command line. Nevertheless it is always preferrable to use the cli config file. Every credential setting is related to a dedicated consumer and provides a set of credential attributes. All this can be specified by a sequence of \u0026ndash;cred options.
Every option value has the format
--cred [:]\u0026lt;attr\u003e=\u0026lt;value\u003e Consumer identity attributes are prefixed with the colon (:). A credential settings always start with a sequence of at least one identity attributes, followed by a sequence of credential attributes. If a credential attribute is followed by an identity attribute a new credential setting is started.
The first credential setting may omit identity attributes. In this case it is used as default credential, always used if no dedicated match is found.
For example:
--cred :type=ociRegistry --cred hostname=ghcr.io --cred usename=mandelsoft --cred password=xyz With the option -X it is possible to pass global settings of the form
-X \u0026lt;attribute\u003e=\u0026lt;value\u003e The value can be a simple type or a json string for complex values. The following attributes are supported:
github.com/mandelsoft/oci/cache [cache]: string
Filesystem folder to use for caching OCI blobs
github.com/mandelsoft/ocm/compat [compat]: bool
Compatibility mode: Avoid generic local access methods and prefer type specific ones.
github.com/mandelsoft/ocm/keeplocalblob [keeplocalblob]: bool
Keep local blobs when importing OCI artefacts to OCI registries from localBlob access methods. By default they will be expanded to OCI artefacts with the access method ociRegistry. If this option is set to true, they will be stored as local blobs, also. The access method will still be localBlob but with a nested ociRegistry access method for describing the global access.
github.com/mandelsoft/ocm/ociuploadrepo [ociuploadrepo]: oci base repository ref
Upload local OCI artefact blobs to a dedicated repository.
github.com/mandelsoft/ocm/signing: JSON
Public and private Key settings given as JSON document with the following format:
{ "publicKeys"": [ "\u0026lt;provider\u003e": { "data": ""\u0026lt;base64\u003e" } ], "privateKeys"": [ "\u0026lt;provider\u003e": { "path": ""\u0026lt;file path\u003e" } ] One of following data fields are possible:
data: base64 encoded binary data stringdata: plain text data path: a file path to read the data from github.com/mandelsoft/tempblobcache [blobcache]: string Foldername for temporary blob cache
The temporary blob cache is used to accessing large blobs from remote sytems. The are temporarily stored in the filesystem, instead of the memory, to avoid blowing up the memory consumption.
Options # -X, --attribute stringArray attribute setting --config string configuration file -C, --cred stringArray credential setting -h, --help help for ocm See Also # ocm add	â€” Add resources or sources to a component archive ocm bootstrap	â€” bootstrap components ocm clean	â€” Cleanup/re-organize elements ocm create	â€” Create transport or component archive ocm describe	â€” Describe artefacts ocm download	â€” Download oci artefacts, resources or complete components ocm get	â€” Get information about artefacts and components ocm show	â€” Show tags or versions ocm sign	â€” Sign components ocm transfer	â€” Transfer artefacts or components ocm verify	â€” Verify component version signatures `}),e.add({id:18,href:"/docs/cli/transfer/commontransportarchive/",title:"commontransportarchive",description:`Usage # ocm transfer commontransportarchive [\u0026lt;options\u0026gt;] \u0026lt;ctf\u0026gt; \u0026lt;target\u0026gt; Description # Transfer content of a Common Transport Archive to the given target repository.
The \u0026ndash;type option accepts a file format for the target archive to use. The following formats are supported:
directory tar tgz The default format is directory. It the option \u0026ndash;overwrite is given, component version in the target repository will be overwritten, if they already exist.
It the option \u0026ndash;resourcesByValue is given, all referential resources will potentially be localized, mapped to component version local resources in the target repository.`,content:`Usage # ocm transfer commontransportarchive [\u0026lt;options\u0026gt;] \u0026lt;ctf\u0026gt; \u0026lt;target\u0026gt; Description # Transfer content of a Common Transport Archive to the given target repository.
The \u0026ndash;type option accepts a file format for the target archive to use. The following formats are supported:
directory tar tgz The default format is directory. It the option \u0026ndash;overwrite is given, component version in the target repository will be overwritten, if they already exist.
It the option \u0026ndash;resourcesByValue is given, all referential resources will potentially be localized, mapped to component version local resources in the target repository. This behaviour can be further influenced by specifying a transfer script with the script option family.
It is possible to use a dedicated transfer script based on spiff. The option \u0026ndash;scriptFile can be used to specify this script by a file name. With \u0026ndash;script it can be taken from the CLI config using an entry of the following format:
type: scripts.ocm.config.ocm.gardener.cloud scripts: \u0026lt;name\u003e: path: \u0026lt;filepath\u003e script: \u0026lt;scriptdata\u003e Only one of the fields path or script can be used.
If no script option is given and the cli config defines a script default this one is used.
Options # -h, --help help for commontransportarchive -f, --overwrite overwrite existing component versions -V, --resourcesByValue transfer resources by-value --script string config name of transfer handler script -s, --scriptFile string filename of transfer handler script -t, --type string archive format (default \u0026quot;directory\u0026quot;) Examples # \$ ocm transfer ctf ctf.tgz ghcr.io/mandelsoft/components See Also # ocm transfer	â€” Transfer artefacts or components `}),e.add({id:19,href:"/docs/cli/create/componentarchive/",title:"componentarchive",description:`Usage # ocm create componentarchive [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; \u0026lt;version\u0026gt; \u0026lt;provider\u0026gt; \u0026lt;path\u0026gt; {--provider \u0026lt;label\u0026gt;=\u0026lt;value\u0026gt;} {\u0026lt;label\u0026gt;=\u0026lt;value\u0026gt;} Description # Create a new component archive. This might be either a directory prepared to host component version content or a tar/tgz file.
The \u0026ndash;type option accepts a file format for the target archive to use. The following formats are supported:
directory tar tgz The default format is directory. It the option \u0026ndash;scheme is given, the given component descriptor format is used/generated.`,content:`Usage # ocm create componentarchive [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; \u0026lt;version\u0026gt; \u0026lt;provider\u0026gt; \u0026lt;path\u0026gt; {--provider \u0026lt;label\u0026gt;=\u0026lt;value\u0026gt;} {\u0026lt;label\u0026gt;=\u0026lt;value\u0026gt;} Description # Create a new component archive. This might be either a directory prepared to host component version content or a tar/tgz file.
The \u0026ndash;type option accepts a file format for the target archive to use. The following formats are supported:
directory tar tgz The default format is directory. It the option \u0026ndash;scheme is given, the given component descriptor format is used/generated. The following schema versions are supported:
ocm.gardener.cloud/v3alpha1:
v2 (default):
Options # -f, --force remove existing content -h, --help help for componentarchive -p, --provider stringArray provider attribute -S, --scheme string schema version (default \u0026quot;v2\u0026quot;) -t, --type string archive format (default \u0026quot;directory\u0026quot;) See Also # ocm create	â€” Create transport or component archive `}),e.add({id:20,href:"/docs/cli/transfer/componentarchive/",title:"componentarchive",description:`Usage # ocm transfer componentarchive [\u0026lt;options\u0026gt;] \u0026lt;source\u0026gt; \u0026lt;target\u0026gt; Description # Transfer a component archive to some component repository. This might be a CTF Archive or a regular repository. If the type CTF is specified the target must already exist, if CTF flavor is specified it will be created if it does not exist.
Besides those explicitly known types a complete repository spec might be configured, either via inline argument or command configuration file and name.`,content:`Usage # ocm transfer componentarchive [\u0026lt;options\u0026gt;] \u0026lt;source\u0026gt; \u0026lt;target\u0026gt; Description # Transfer a component archive to some component repository. This might be a CTF Archive or a regular repository. If the type CTF is specified the target must already exist, if CTF flavor is specified it will be created if it does not exist.
Besides those explicitly known types a complete repository spec might be configured, either via inline argument or command configuration file and name.
The \u0026ndash;type option accepts a file format for the target archive to use. The following formats are supported:
directory tar tgz The default format is directory. Options # -h, --help help for componentarchive -t, --type string archive format (default \u0026quot;directory\u0026quot;) See Also # ocm transfer	â€” Transfer artefacts or components `}),e.add({id:21,href:"/docs/cli/bootstrap/componentversions/",title:"componentversions",description:`Usage # ocm bootstrap componentversions [\u0026lt;options\u0026gt;] \u0026lt;action\u0026gt; {\u0026lt;component-reference\u0026gt;} {\u0026lt;resource id field\u0026gt;} Description # Use the simple TOI bootstrap mechanism to execute actions for a TOI package resource based on the content of an OCM component version and some command input describing the dedicated installation target.
The package resource must have the type toiPackage. This is a simple YAML file resource describing the bootstrapping of a dedicated kind of software. See also the topic ocm toi toi-bootstrapping.`,content:`Usage # ocm bootstrap componentversions [\u0026lt;options\u0026gt;] \u0026lt;action\u0026gt; {\u0026lt;component-reference\u0026gt;} {\u0026lt;resource id field\u0026gt;} Description # Use the simple TOI bootstrap mechanism to execute actions for a TOI package resource based on the content of an OCM component version and some command input describing the dedicated installation target.
The package resource must have the type toiPackage. This is a simple YAML file resource describing the bootstrapping of a dedicated kind of software. See also the topic ocm toi toi-bootstrapping.
THis resource finally describes an executor image, which will be executed in a container with the installation source and (instance specific) user settings. The container is just executed, the framework make no assumption about the meaning/outcome of the execution. Therefore, any kind of actions can be described and issued this way, not on installation handling.
The first matching resource of this type is selected. Optionally a set of identity attribute can be specified used to refine the match. This can be the resource name and/or other key/value pairs (\u0026lt;attr\u0026gt;=\u0026lt;value\u0026gt;).
If no output file is provided, the yaml representation of the outputs are printed to standard out. If the output file is a directory, for every output a dedicated file is created, otherwise the yaml representation is stored to the file.
If no credentials file name is provided (option -c) the file TOICredentials is used, if present. If no parameter file name is provided (option -p) the file TOIParameters is used, if present.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.
Options # -c, --credentials string credentials file -h, --help help for componentversions -o, --outputs string output file/directory -p, --parameters string parameter file Examples # \$ ocm toi bootstrap componentversion ghcr.io/mandelsoft/ocmdemoinstaller:0.0.1-dev See Also # ocm bootstrap	â€” bootstrap components Additional Help Topics # ocm bootstrap componentversions toi-bootstrapping	â€” Tiny OCM Installer based on component versions `}),e.add({id:22,href:"/docs/cli/download/componentversions/",title:"componentversions",description:"Usage # ocm download componentversions [\u0026lt;options\u0026gt;] {\u0026lt;components\u0026gt;} Description # Download component versions from an OCM repository. The result is stored in component archives. The files are named according to the component version name. If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax \u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:",content:`Usage # ocm download componentversions [\u0026lt;options\u0026gt;] {\u0026lt;components\u0026gt;} Description # Download component versions from an OCM repository. The result is stored in component archives.
The files are named according to the component version name.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry The \u0026ndash;type option accepts a file format for the target archive to use. The following formats are supported:
directory tar tgz The default format is directory. Options # -h, --help help for componentversions -O, --outfile string output file or directory -r, --repo string repository name or spec -t, --type string archive format (default \u0026quot;directory\u0026quot;) See Also # ocm download	â€” Download oci artefacts, resources or complete components `}),e.add({id:23,href:"/docs/cli/get/componentversions/",title:"componentversions",description:"Usage # ocm get componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} Description # Get lists all component versions specified, if only a component is specified all versions are listed. If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax \u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references: [\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications",content:`Usage # ocm get componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} Description # Get lists all component versions specified, if only a component is specified all versions are listed.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry With the option \u0026ndash;closure the complete reference tree of a component reference is traversed.
It the option \u0026ndash;scheme is given, the given component descriptor is converted to given format for output. The following schema versions are supported:
ocm.gardener.cloud/v3alpha1:
v2:
With the option \u0026ndash;output the output mode can be selected. The following modes are supported:
JSON json tree wide yaml Options # -c, --closure follow component reference nesting -h, --help help for componentversions -o, --output string output mode (JSON, json, tree, wide, yaml) -r, --repo string repository name or spec -S, --scheme string schema version -s, --sort stringArray sort fields Examples # \$ ocm get componentversion ghcr.io/mandelsoft/kubelink \$ ocm get componentversion --repo OCIRegistry:ghcr.io mandelsoft/kubelink See Also # ocm get	â€” Get information about artefacts and components `}),e.add({id:24,href:"/docs/cli/sign/componentversions/",title:"componentversions",description:"Usage # ocm sign componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} Description # Sign specified component versions. If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax \u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references: [\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications [\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:",content:`Usage # ocm sign componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} Description # Sign specified component versions.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry The \u0026ndash;public-key and \u0026ndash;private-key options can be used to define public and private keys on the command line. The options have an argument of the form [\u0026lt;name\u0026gt;=]\u0026lt;filepath\u0026gt;. The optional name specifies the signature name the key should be used for. By default this is the signature name specified with the option \u0026ndash;signature.
Alternatively a key can be specified as base64 encoded string if the argument start with the prefix ! or as direct string with the prefix =.
If in signing mode a public key is specified, existing signatures for the given signature name will be verified, instead of recreated.
The following signing types are supported with option \u0026ndash;algorithm:
RSASSA-PKCS1-V1_5 (default):
rsa-signingsservice:
The following normalization modes are supported with option \u0026ndash;normalization:
jsonNormalisation/v1 (default):
jsonNormalisation/v2:
The following hash modes are supported with option \u0026ndash;hash:
NO-DIGEST:
sha256 (default):
sha512:
Options # -S, --algorithm string signature handler (default \u0026quot;RSASSA-PKCS1-V1_5\u0026quot;) --ca-cert stringArray Additional root certificates -H, --hash string hash algorithm (default \u0026quot;sha256\u0026quot;) -h, --help help for componentversions -I, --issuer string issuer name -N, --normalization string normalization algorithm (default \u0026quot;jsonNormalisation/v1\u0026quot;) -K, --private-key stringArray private key setting -k, --public-key stringArray public key setting -R, --recursive recursively sign component versions (default true) -r, --repo string repository name or spec -s, --signature stringArray signature name --update update digest in component versions (default true) -V, --verify verify existing digests (default true) Examples # \$ ocm sign componentversion --signature mandelsoft --private-key=mandelsoft.key ghcr.io/mandelsoft/kubelink See Also # ocm sign	â€” Sign components `}),e.add({id:25,href:"/docs/cli/transfer/componentversions/",title:"componentversions",description:"Usage # ocm transfer componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} \u0026lt;target\u0026gt; Description # Transfer all component versions specified to the given target repository. If only a component (instead of a component version) is specified all versions are transferred. If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax \u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:",content:`Usage # ocm transfer componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} \u0026lt;target\u0026gt; Description # Transfer all component versions specified to the given target repository. If only a component (instead of a component version) is specified all versions are transferred.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry The \u0026ndash;type option accepts a file format for the target archive to use. The following formats are supported:
directory tar tgz The default format is directory. With the option \u0026ndash;closure the complete reference tree of a component reference is traversed.
It the option \u0026ndash;overwrite is given, component version in the target repository will be overwritten, if they already exist.
It the option \u0026ndash;resourcesByValue is given, all referential resources will potentially be localized, mapped to component version local resources in the target repository. This behaviour can be further influenced by specifying a transfer script with the script option family.
It is possible to use a dedicated transfer script based on spiff. The option \u0026ndash;scriptFile can be used to specify this script by a file name. With \u0026ndash;script it can be taken from the CLI config using an entry of the following format:
type: scripts.ocm.config.ocm.gardener.cloud scripts: \u0026lt;name\u003e: path: \u0026lt;filepath\u003e script: \u0026lt;scriptdata\u003e Only one of the fields path or script can be used.
If no script option is given and the cli config defines a script default this one is used.
Options # -c, --closure follow component reference nesting -h, --help help for componentversions -f, --overwrite overwrite existing component versions -r, --repo string repository name or spec -V, --resourcesByValue transfer resources by-value --script string config name of transfer handler script -s, --scriptFile string filename of transfer handler script -t, --type string archive format (default \u0026quot;directory\u0026quot;) Examples # \$ ocm transfer components -t tgz ghcr.io/mandelsoft/kubelink ctf.tgz \$ ocm transfer components -t tgz --repo OCIRegistry:ghcr.io mandelsoft/kubelink ctf.tgz See Also # ocm transfer	â€” Transfer artefacts or components `}),e.add({id:26,href:"/docs/cli/verify/componentversions/",title:"componentversions",description:"Usage # ocm verify componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} Description # Verify signature of specified component versions. If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax \u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references: [\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications [\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:",content:`Usage # ocm verify componentversions [\u0026lt;options\u0026gt;] {\u0026lt;component-reference\u0026gt;} Description # Verify signature of specified component versions.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry The \u0026ndash;public-key and \u0026ndash;private-key options can be used to define public and private keys on the command line. The options have an argument of the form [\u0026lt;name\u0026gt;=]\u0026lt;filepath\u0026gt;. The optional name specifies the signature name the key should be used for. By default this is the signature name specified with the option \u0026ndash;signature.
Alternatively a key can be specified as base64 encoded string if the argument start with the prefix ! or as direct string with the prefix =.
Options # --ca-cert stringArray Additional root certificates -h, --help help for componentversions -k, --public-key stringArray public key setting -r, --repo string repository name or spec -s, --signature stringArray signature name -V, --verify verify existing digests Examples # \$ ocm verify componentversion --signature mandelsoft --public-key=mandelsoft.key ghcr.io/mandelsoft/kubelink See Also # ocm verify	â€” Verify component version signatures `}),e.add({id:27,href:"/docs/cli/create/",title:"create",description:"Usage # ocm create [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for create See Also # Sub Commands # ocm create componentarchive	â€” create new component archive ocm create rsakeypair	â€” create RSA public key pair ocm create transportarchive	â€” create new OCI/OCM transport archive ",content:"Usage # ocm create [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for create See Also # Sub Commands # ocm create componentarchive	â€” create new component archive ocm create rsakeypair	â€” create RSA public key pair ocm create transportarchive	â€” create new OCI/OCM transport archive "}),e.add({id:28,href:"/docs/cli/get/credentials/",title:"credentials",description:`Usage # ocm get credentials {\u0026lt;consumer property\u0026gt;=\u0026lt;value\u0026gt;} Description # Try to resolve a given consumer specification against the configured credential settings and show the found credential attributes.
For the following usage contexts with matchers and standard identity matchers exist:
OCIRegistry: OCI registry credential matcher
It matches the OCIRegistry consumer type and additionally acts like the hostpath type.
exact: exact match of given pattern set
hostpath: Host and path based credential matcher`,content:`Usage # ocm get credentials {\u0026lt;consumer property\u0026gt;=\u0026lt;value\u0026gt;} Description # Try to resolve a given consumer specification against the configured credential settings and show the found credential attributes.
For the following usage contexts with matchers and standard identity matchers exist:
OCIRegistry: OCI registry credential matcher
It matches the OCIRegistry consumer type and additionally acts like the hostpath type.
exact: exact match of given pattern set
hostpath: Host and path based credential matcher
This matcher works on the following properties:
hostname (required): the hostname of a server port (optional): the port of a server pathprefix (optional): a path prefix to match. The element with the most matching path components is selected (separator is /). partial: complete match of given pattern ignoring additional attributes
The used matcher is derived from the consumer attribute type. For all other consumer types a matcher matching all attributes will be used. The usage of a dedicated matcher can be enforced by the option \u0026ndash;matcher.
Options # -h, --help help for credentials -m, --matcher string matcher type override See Also # ocm get	â€” Get information about artefacts and components `}),e.add({id:29,href:"/docs/cli/describe/",title:"describe",description:"Usage # ocm describe [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for describe See Also # Sub Commands # ocm describe artefacts	â€” describe artefact version ",content:"Usage # ocm describe [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for describe See Also # Sub Commands # ocm describe artefacts	â€” describe artefact version "}),e.add({id:30,href:"/docs/cli/download/",title:"download",description:"Usage # ocm download [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for download See Also # Sub Commands # ocm download artefacts	â€” download oci artefacts ocm download componentversions	â€” download ocm component versions ocm download resources	â€” download resources of a component version ",content:"Usage # ocm download [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for download See Also # Sub Commands # ocm download artefacts	â€” download oci artefacts ocm download componentversions	â€” download ocm component versions ocm download resources	â€” download resources of a component version "}),e.add({id:31,href:"/docs/cli/get/",title:"get",description:"Usage # ocm get [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for get See Also # Sub Commands # ocm get artefacts	â€” get artefact version ocm get componentversions	â€” get component version ocm get credentials	â€” Get credentials for a dedicated consumer spec ocm get references	â€” get references of a component version ocm get resources	â€” get resources of a component version ocm get sources	â€” get sources of a component version ",content:"Usage # ocm get [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for get See Also # Sub Commands # ocm get artefacts	â€” get artefact version ocm get componentversions	â€” get component version ocm get credentials	â€” Get credentials for a dedicated consumer spec ocm get references	â€” get references of a component version ocm get resources	â€” get resources of a component version ocm get sources	â€” get sources of a component version "}),e.add({id:32,href:"/docs/cli/add/references/",title:"references",description:`Usage # ocm add references [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;} Description # Add aggregation information specified in a resource file to a component version. So far only component archives are supported as target.
Templating: All yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding.`,content:`Usage # ocm add references [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;} Description # Add aggregation information specified in a resource file to a component version. So far only component archives are supported as target.
Templating: All yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, commmand line settings.
Note: Variable names are case-sensitive.
Example:
-- MY_VAL=test There are several templaters that can be selected by the \u0026ndash;templater option:
envsubst: simple value substitution with the drone/envsubst templater. It supports string values, only. Complext settings will be json encoded.
key: subkey: "abc \${MY_VAL}" go: go templating supports complex values.
key: subkey: "abc {{.MY_VAL}}" spiff: spiff templating supports complex values. the settings are accessible using the binding values.
key: subkey: "abc (( values.MY_VAL ))" This command accepts reference specification files describing the references to add to a component version.
The resource specification supports the following blob input types, specified with the field type in the input field:
Input type dir
The path must denote a directory relative to the resources file, which is packed with tar and optionally compressed if the compress field is set to true. If the field preserveDir is set to true the directory itself is added to the tar. If the field followSymLinks is set to true, symbolic links are not packed but their targets files or folders. With the list fields includeFiles and excludeFiles it is possible to specify which files should be included or excluded. The values are regular expression used to match relative file paths. If no inlcudes are specified all file not explicitly excluded are used.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to directory relative to the resource file location.
mediaType string
This OPTIONAL property describes the media type to store with the local blob. The default media type is application/x-tar and application/gzip if compression is enabled.
compress bool
This OPTIONAL property describes whether the file content should be stored compressed or not.
preserveDir bool
This OPTIONAL property describes whether the specified directory with its basename should be included as top level folder.
followSymlinks bool
This OPTIONAL property describes whether symbolic links should be followed or included as links.
excludeFiles list of regex
This OPTIONAL property describes regular expressions used to match files that should NOT be included in the tar file. It takes precedence over the include match.
includeFiles list of regex
This OPTIONAL property describes regular expressions used to match files that should be included in the tar file. If this option is not given all files not explicitly excluded are used.
Input type docker
The path must denote an image tag that can be found in the local docker daemon. The denoted image is packed an OCI artefact set.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the image name to import from the local docker daemon.
Input type file
The path must denote a file relative the the resources file. The content is compressed if the compress field is set to true.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to the helm chart relative to the resource file location.
mediaType string
This OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.
compress bool
This OPTIONAL property describes whether the file content should be stored compressed or not.
Input type helm
The path must denote an helm chart archive or directory relative to the resources file. The denoted chart is packed as an OCI artefact set. Additional provider info is taken from a file with the same name and the suffix .prov.
If the chart should just be stored as archive, please use the type file or dir.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to the helm chart relative to the resource file location.
version string
This OPTIONAL property can be set to configure an explicit version hint. If not specified the versio from the chart will be used. Basically, it is a good practice to use the component version for local resources This can be achieved by using templating for this attribute in the resource file.
Input type spiff
The path must denote a spiff template relative the the resources file. The content is compressed if the compress field is set to true.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to the helm chart relative to the resource file location.
mediaType string
This OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.
compress bool
This OPTIONAL property describes whether the file content should be stored compressed or not.
values map[string]any
This OPTIONAL property describes an additioanl value binding for the template processing. It will be available under the node values.
libraries []string
This OPTIONAL property describes a list of spiff libraries to include in template processing.
Options # --addenv access environment for templating -h, --help help for references -s, --settings stringArray settings file with variable settings (yaml) --templater string templater to use (subst, spiff, go) (default \u0026quot;subst\u0026quot;) See Also # ocm add	â€” Add resources or sources to a component archive `}),e.add({id:33,href:"/docs/cli/get/references/",title:"references",description:"Usage # ocm get references [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }} Description # Get references of a component version. References are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments. If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax \u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:",content:`Usage # ocm get references [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }} Description # Get references of a component version. References are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry With the option \u0026ndash;closure the complete reference tree of a component reference is traversed.
If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.
With the option \u0026ndash;output the output mode can be selected. The following modes are supported:
JSON json tree wide yaml Options # -c, --closure follow component reference nesting -h, --help help for references --lookup stringArray repository name or spec for closure lookup fallback -o, --output string output mode (JSON, json, tree, wide, yaml) -r, --repo string repository name or spec -s, --sort stringArray sort fields See Also # ocm get	â€” Get information about artefacts and components `}),e.add({id:34,href:"/docs/cli/add/resources/",title:"resources",description:`Usage # ocm add resources [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;} Description # Add resources specified in a resource file to a component version. So far only component archives are supported as target.
Templating: All yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding.`,content:`Usage # ocm add resources [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;} Description # Add resources specified in a resource file to a component version. So far only component archives are supported as target.
Templating: All yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, commmand line settings.
Note: Variable names are case-sensitive.
Example:
-- MY_VAL=test There are several templaters that can be selected by the \u0026ndash;templater option:
envsubst: simple value substitution with the drone/envsubst templater. It supports string values, only. Complext settings will be json encoded.
key: subkey: "abc \${MY_VAL}" go: go templating supports complex values.
key: subkey: "abc {{.MY_VAL}}" spiff: spiff templating supports complex values. the settings are accessible using the binding values.
key: subkey: "abc (( values.MY_VAL ))" This command accepts resource specification files describing the resources to add to a component version.
The resource specification supports the following blob input types, specified with the field type in the input field:
Input type dir
The path must denote a directory relative to the resources file, which is packed with tar and optionally compressed if the compress field is set to true. If the field preserveDir is set to true the directory itself is added to the tar. If the field followSymLinks is set to true, symbolic links are not packed but their targets files or folders. With the list fields includeFiles and excludeFiles it is possible to specify which files should be included or excluded. The values are regular expression used to match relative file paths. If no inlcudes are specified all file not explicitly excluded are used.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to directory relative to the resource file location.
mediaType string
This OPTIONAL property describes the media type to store with the local blob. The default media type is application/x-tar and application/gzip if compression is enabled.
compress bool
This OPTIONAL property describes whether the file content should be stored compressed or not.
preserveDir bool
This OPTIONAL property describes whether the specified directory with its basename should be included as top level folder.
followSymlinks bool
This OPTIONAL property describes whether symbolic links should be followed or included as links.
excludeFiles list of regex
This OPTIONAL property describes regular expressions used to match files that should NOT be included in the tar file. It takes precedence over the include match.
includeFiles list of regex
This OPTIONAL property describes regular expressions used to match files that should be included in the tar file. If this option is not given all files not explicitly excluded are used.
Input type docker
The path must denote an image tag that can be found in the local docker daemon. The denoted image is packed an OCI artefact set.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the image name to import from the local docker daemon.
Input type file
The path must denote a file relative the the resources file. The content is compressed if the compress field is set to true.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to the helm chart relative to the resource file location.
mediaType string
This OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.
compress bool
This OPTIONAL property describes whether the file content should be stored compressed or not.
Input type helm
The path must denote an helm chart archive or directory relative to the resources file. The denoted chart is packed as an OCI artefact set. Additional provider info is taken from a file with the same name and the suffix .prov.
If the chart should just be stored as archive, please use the type file or dir.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to the helm chart relative to the resource file location.
version string
This OPTIONAL property can be set to configure an explicit version hint. If not specified the versio from the chart will be used. Basically, it is a good practice to use the component version for local resources This can be achieved by using templating for this attribute in the resource file.
Input type spiff
The path must denote a spiff template relative the the resources file. The content is compressed if the compress field is set to true.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to the helm chart relative to the resource file location.
mediaType string
This OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.
compress bool
This OPTIONAL property describes whether the file content should be stored compressed or not.
values map[string]any
This OPTIONAL property describes an additioanl value binding for the template processing. It will be available under the node values.
libraries []string
This OPTIONAL property describes a list of spiff libraries to include in template processing.
Options # --addenv access environment for templating -h, --help help for resources -s, --settings stringArray settings file with variable settings (yaml) --templater string templater to use (subst, spiff, go) (default \u0026quot;subst\u0026quot;) See Also # ocm add	â€” Add resources or sources to a component archive `}),e.add({id:35,href:"/docs/cli/download/resources/",title:"resources",description:`Usage # ocm download resources [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }} Description # Download resources of a component version. Resources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.
The option -O is used to declare the output destination. For a single resource to download, this is the file written for the resource blob. If multiple resources are selected, a directory structure is written into the given directory for every involved component version as follows:`,content:`Usage # ocm download resources [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }} Description # Download resources of a component version. Resources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.
The option -O is used to declare the output destination. For a single resource to download, this is the file written for the resource blob. If multiple resources are selected, a directory structure is written into the given directory for every involved component version as follows:
\u0026lt;component\u003e/\u0026lt;version\u003e{/\u0026lt;nested component\u003e/\u0026lt;version\u003e} The resource files are named according to the resource identity in the component descriptor. If this identity is just the resource name, this name is ised. If additional identity attributes are required, this name is append by a comma separated list of \u0026lt;name\u0026gt;=\u0026amp;lt\u0026gt;value\u0026gt; pairs separated by a \u0026ldquo;-\u0026rdquo; from the plain name. This attribute list is alphabetical order:
\u0026lt;resource name\u003e[-[\u0026lt;name\u003e=\u0026lt\u003evalue\u003e]{,\u0026lt;name\u003e=\u0026lt\u003evalue\u003e}] If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry The library supports some downloads with semantics based on resource types. For example a helm chart can be download directly as helm chart archive, even if stored as OCI artefact. This is handled by download handler. Their usage can be enabled with the \u0026ndash;download-handlers option. Otherwise the resource as returned by the access method is stored.
With the option \u0026ndash;closure the complete reference tree of a component reference is traversed.
If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.
Options # -c, --closure follow component reference nesting -d, --download-handlers use download handler if possible -h, --help help for resources --lookup stringArray repository name or spec for closure lookup fallback -O, --outfile string output file or directory -r, --repo string repository name or spec See Also # ocm download	â€” Download oci artefacts, resources or complete components `}),e.add({id:36,href:"/docs/cli/get/resources/",title:"resources",description:"Usage # ocm get resources [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }} Description # Get resources of a component version. Resources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments. If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax \u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:",content:`Usage # ocm get resources [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }} Description # Get resources of a component version. Resources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry With the option \u0026ndash;closure the complete reference tree of a component reference is traversed.
If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.
With the option \u0026ndash;output the output mode can be selected. The following modes are supported:
JSON json tree treewide wide yaml Options # -c, --closure follow component reference nesting -h, --help help for resources --lookup stringArray repository name or spec for closure lookup fallback -o, --output string output mode (JSON, json, tree, treewide, wide, yaml) -r, --repo string repository name or spec -s, --sort stringArray sort fields See Also # ocm get	â€” Get information about artefacts and components `}),e.add({id:37,href:"/docs/cli/create/rsakeypair/",title:"rsakeypair",description:`Usage # ocm create rsakeypair [\u0026lt;private key file\u0026gt; [\u0026lt;public key file\u0026gt;]] {\u0026lt;subject-attribute\u0026gt;=\u0026lt;value\u0026gt;} Description # Create an RSA public key pair and save to files.
The default for the filename to store the private key is rsa.priv. If no public key file is specified, its name will be derived from the filename for the private key (suffix .pub for public key or .cert for certificate). If a certificate authority is given (\u0026ndash;cacert) the public key will be signed.`,content:`Usage # ocm create rsakeypair [\u0026lt;private key file\u0026gt; [\u0026lt;public key file\u0026gt;]] {\u0026lt;subject-attribute\u0026gt;=\u0026lt;value\u0026gt;} Description # Create an RSA public key pair and save to files.
The default for the filename to store the private key is rsa.priv. If no public key file is specified, its name will be derived from the filename for the private key (suffix .pub for public key or .cert for certificate). If a certificate authority is given (\u0026ndash;cacert) the public key will be signed. In this case a subject (at least common name/issuer) and a private key (\u0026ndash;cakey) is required. If only a subject is given, the public key will be self-signed.
For signing the public key the following subject attributes are supported:
CN, common-name, issuer: Common Name/Issuer O, organization, org: Organization OU, organizational-unit, org-unit: Organizational Unit STREET (multiple): Street Address POSTALCODE, postal-code (multiple): Postal Code L, locality (multiple): Locality S, province, (multiple): Province C, country, (multiple): Country Options # --cacert string certificate authority to sign public key --cakey string private key for certificate authority -h, --help help for rsakeypair --validity duration certificate validity (default 87600h0m0s) Examples # \$ ocm create rsakeypair mandelsoft.priv mandelsoft.cert issuer=mandelsoft See Also # ocm create	â€” Create transport or component archive `}),e.add({id:38,href:"/docs/cli/show/",title:"show",description:"Usage # ocm show [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for show See Also # Sub Commands # ocm show tags	â€” show dedicated tags of OCI artefacts ocm show versions	â€” show dedicated versions (semver compliant) ",content:"Usage # ocm show [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for show See Also # Sub Commands # ocm show tags	â€” show dedicated tags of OCI artefacts ocm show versions	â€” show dedicated versions (semver compliant) "}),e.add({id:39,href:"/docs/cli/sign/",title:"sign",description:"Usage # ocm sign [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for sign See Also # Sub Commands # ocm sign componentversions	â€” Sign component version ",content:"Usage # ocm sign [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for sign See Also # Sub Commands # ocm sign componentversions	â€” Sign component version "}),e.add({id:40,href:"/docs/cli/add/sources/",title:"sources",description:`Usage # ocm add sources [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;} Description # Add source information specified in a resource file to a component version. So far only component archives are supported as target.
Templating: All yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding.`,content:`Usage # ocm add sources [\u0026lt;options\u0026gt;] \u0026lt;target\u0026gt; {\u0026lt;resourcefile\u0026gt; | \u0026lt;var\u0026gt;=\u0026lt;value\u0026gt;} Description # Add source information specified in a resource file to a component version. So far only component archives are supported as target.
Templating: All yaml/json defined resources can be templated. Variables are specified as regular arguments following the syntax \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt;. Additionally settings can be specified by a yaml file using the \u0026ndash;settings option. With the option \u0026ndash;addenv environment variables are added to the binding. Values are overwritten in the order environment, settings file, commmand line settings.
Note: Variable names are case-sensitive.
Example:
-- MY_VAL=test There are several templaters that can be selected by the \u0026ndash;templater option:
envsubst: simple value substitution with the drone/envsubst templater. It supports string values, only. Complext settings will be json encoded.
key: subkey: "abc \${MY_VAL}" go: go templating supports complex values.
key: subkey: "abc {{.MY_VAL}}" spiff: spiff templating supports complex values. the settings are accessible using the binding values.
key: subkey: "abc (( values.MY_VAL ))" This command accepts (re)source specification files describing the sources to add to a component version.
The resource specification supports the following blob input types, specified with the field type in the input field:
Input type dir
The path must denote a directory relative to the resources file, which is packed with tar and optionally compressed if the compress field is set to true. If the field preserveDir is set to true the directory itself is added to the tar. If the field followSymLinks is set to true, symbolic links are not packed but their targets files or folders. With the list fields includeFiles and excludeFiles it is possible to specify which files should be included or excluded. The values are regular expression used to match relative file paths. If no inlcudes are specified all file not explicitly excluded are used.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to directory relative to the resource file location.
mediaType string
This OPTIONAL property describes the media type to store with the local blob. The default media type is application/x-tar and application/gzip if compression is enabled.
compress bool
This OPTIONAL property describes whether the file content should be stored compressed or not.
preserveDir bool
This OPTIONAL property describes whether the specified directory with its basename should be included as top level folder.
followSymlinks bool
This OPTIONAL property describes whether symbolic links should be followed or included as links.
excludeFiles list of regex
This OPTIONAL property describes regular expressions used to match files that should NOT be included in the tar file. It takes precedence over the include match.
includeFiles list of regex
This OPTIONAL property describes regular expressions used to match files that should be included in the tar file. If this option is not given all files not explicitly excluded are used.
Input type docker
The path must denote an image tag that can be found in the local docker daemon. The denoted image is packed an OCI artefact set.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the image name to import from the local docker daemon.
Input type file
The path must denote a file relative the the resources file. The content is compressed if the compress field is set to true.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to the helm chart relative to the resource file location.
mediaType string
This OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.
compress bool
This OPTIONAL property describes whether the file content should be stored compressed or not.
Input type helm
The path must denote an helm chart archive or directory relative to the resources file. The denoted chart is packed as an OCI artefact set. Additional provider info is taken from a file with the same name and the suffix .prov.
If the chart should just be stored as archive, please use the type file or dir.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to the helm chart relative to the resource file location.
version string
This OPTIONAL property can be set to configure an explicit version hint. If not specified the versio from the chart will be used. Basically, it is a good practice to use the component version for local resources This can be achieved by using templating for this attribute in the resource file.
Input type spiff
The path must denote a spiff template relative the the resources file. The content is compressed if the compress field is set to true.
This blob type specification supports the following fields:
path string
This REQUIRED property describes the file path to the helm chart relative to the resource file location.
mediaType string
This OPTIONAL property describes the media type to store with the local blob. The default media type is application/octet-stream and application/gzip if compression is enabled.
compress bool
This OPTIONAL property describes whether the file content should be stored compressed or not.
values map[string]any
This OPTIONAL property describes an additioanl value binding for the template processing. It will be available under the node values.
libraries []string
This OPTIONAL property describes a list of spiff libraries to include in template processing.
Options # --addenv access environment for templating -h, --help help for sources -s, --settings stringArray settings file with variable settings (yaml) --templater string templater to use (subst, spiff, go) (default \u0026quot;subst\u0026quot;) See Also # ocm add	â€” Add resources or sources to a component archive `}),e.add({id:41,href:"/docs/cli/get/sources/",title:"sources",description:"Usage # ocm get sources [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }} Description # Get sources of a component version. Sources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments. If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax \u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:",content:`Usage # ocm get sources [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;name\u0026gt; { \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; }} Description # Get sources of a component version. Sources are specified by identities. An identity consists of a name argument followed by optional \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; arguments.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry With the option \u0026ndash;closure the complete reference tree of a component reference is traversed.
If a component lookup for building a reference closure is required the \u0026ndash;lookup option can be used to specify a fallback lookup repository. By default the component versions are searched in the repository holding the component version for which the closure is determined. For Component Archives this is never possible, because it only contains a single component version. Therefore, in this scenario this option must always be specified to be able to follow component references.
With the option \u0026ndash;output the output mode can be selected. The following modes are supported:
JSON json tree wide yaml Options # -c, --closure follow component reference nesting -h, --help help for sources --lookup stringArray repository name or spec for closure lookup fallback -o, --output string output mode (JSON, json, tree, wide, yaml) -r, --repo string repository name or spec -s, --sort stringArray sort fields See Also # ocm get	â€” Get information about artefacts and components `}),e.add({id:42,href:"/docs/cli/show/tags/",title:"tags",description:"Usage # ocm show tags [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;version pattern\u0026gt;} Description # Match tags of an artefact against some patterns. If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax \u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references. [\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification: [\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.",content:`Usage # ocm show tags [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;version pattern\u0026gt;} Description # Match tags of an artefact against some patterns.
If the repository/registry option is specified, the given names are interpreted relative to the specified registry using the syntax
\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as extended CI artefact references.
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e]/\u0026lt;OCI repository name\u003e[:\u0026lt;tag\u003e][@\u0026lt;digest\u003e] The \u0026ndash;repo option takes a repository/OCI registry specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz are possible.
Using the JSON variant any repository type supported by the linked library can be used:
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry Options # -h, --help help for tags -l, --latest show only latest tags -r, --repo string repository name or spec -o, --semantic show semantic tags -s, --semver show only semver compliant tags Examples # \$ oci show tags ghcr.io/mandelsoft/kubelink See Also # ocm show	â€” Show tags or versions `}),e.add({id:43,href:"/docs/cli/bootstrap_componentversions/toi-bootstrapping/",title:"toi-bootstrapping",description:`Description # TOI is a small toolset on top of the Open Component Model. It provides a possibility to run images taken from a component version with user configuration and feed them with the content of this component version. It is some basic mechanism which can be used to execute simple installation steps based on content described by the Open Component Model (see ocm bootstrap componentversions).
Therefore, a dedicated resource type toiPackage is defined.`,content:`Description # TOI is a small toolset on top of the Open Component Model. It provides a possibility to run images taken from a component version with user configuration and feed them with the content of this component version. It is some basic mechanism which can be used to execute simple installation steps based on content described by the Open Component Model (see ocm bootstrap componentversions).
Therefore, a dedicated resource type toiPackage is defined. It is selected by a resource identity pattern. The first resource matching the pattern is used. A possible use case could be to provide different packages for different environments. The resource can use an identity attribute platform=\u0026lt;value\u0026gt;. By specifying just the platform attribute, the appropriate package will be chosen.
The bootstrap command uses this resource to determine a TOI executor together executor configuration and additional client specific settings to describe a dedicated installation.
To do this the package describes dedicated actions that can be executed by the bootstrap command. Every action refers to an executor, which is executed to perform the action. Finally, an executor is an image following the TOI specification for passing information into the image execution and receiving results from the execution. Such an image is described in two ways:
it either describes a resource of type ociImage or it describes a resource of type toiExecutor, which defines the image to use and some default settings and further describes the features and requirements of the executor image. The package described credentials requirements and required user configuration which must passed along with the bootstrap command. After validation of the input finally a container with the selected executor image is created, that contains the content of the initial component version in form of a Common Transport Archive and all the specified configuration data.
The execution of the container may do the needful to achieve the goal of the requested action and provide some labeled output files, which will be passed to the caller.
The toiPackage Resource # This resource describes an installable software package, whose content is contained in the component version, which contains the package resource.
It is a plain yaml resource with the media types media type application/x-yaml, text/yaml or application/vnd.toi.gardener.cloud.package.v1+yaml) containing information required to control the instantiation of an executor.
It has the following format:
executors []ExecutorSpecification
configTemplate (optional) yaml
This a spiff template used to generate The user config that is finally passed to the executor. If no template is specified the user parameter input will be processed directly without template.
configScheme (optional) yaml
This is a JSONSCHEMA used to validate the user input prior to merging with the template
templateLibraries (optional) []ResourceReference
This is a list of resources whose content is used as additional stubs for the template processing.
credentials (optional) map[string]CredentialRequest
Here the package may request the provisioning of some credentials with a dedicated name/purpose and structure. If specified the bootstrap command requites the specification of a credentials file providing the information how to satisfy those credential requests.
ExecutorSpecification # The executor specification describes the available actions and their mapping to executors. It uses the following fields:
actions []string
The list of actions this executor can be used for. If nothings is specified the executor will be used for all actions. The first matching executor entry will be used to execute an action by the bootstrap command
resourceRef []ResourceReference
An OCM resource reference describing a component version resource relative to the component version containing the package resource.
config (optional) yaml
This is optional static executor config passed to the executor as is. It is to describe the set of elements on which the actual execution of the executor should work on.
parameterMapping (optional) spiff yaml
This is an optional spiff template used to process the actual parameter set passed by the caller to transform it to the requirements of the actual executor.
A package has global parameter setting, but possibly multiple different executors for different action. They might have different requirements/formats concerning the parameter input. There the executor specification allows to map the provided user input, accordingly
credentialMapping (optional) map[string]string
This is an optional mapping to map credential names used by the package to the needs of dedicated executors.
A package has global parameter setting, but possibly multiple different executors for different action. They might have different requirements/formats concerning the parameter input. There the executor specification allows to map the provided user input, accordingly
image (development) object
Instead of a resourceRef it is possible to directly specify an absolute image.
ATTENTION: this is intended for development purposes, ONLY. Do not use it for final component versions.
It has the field ref and the optional field digest.
outputs (optional) map[string]string
This field can be used to map the names of outputs provided by a dedicated executor outputs to package outputs.
ResourceReference # An OCM resource reference describes a resource of a component version. It is always evaluated relative to the component version providing the resource that contains the resource reference. It uses the following fields:
resourcePath (optional) []Identity
This is sequence of reference identities used to follow a chain of component version references starting with the actual component version. If not specified the specified resource will be taken from the actual component version.
resource Identity
This is the identity of the resource in the selected component version.
Identity # An identity specification is a map[string]string. It describes the identity attributes of a desired resource in a a component version. It always has at least one identity attribute name, which is the resource name field of the desired resource. If this resource defines additional identity attributes, the complete set must be specified.
The toiExecutor Resource # Instead of directly describing an image resource i the package file, it is possible to refer to a resource of type toiExecutor. This is a yaml file with the media type application/x-yaml, text/yaml or application/vnd.toi.gardener.cloud.package.v1+yaml) containing common information about the executor executor. If used by the package, this information is used to validate settings in the package specification.
It has the following format:
imageRef ResourceReference
This field reference the image resource relative to the component version providing the executor resource
configTemplate (optional) yaml
This a spiff template used to generate The executor config from the package specification that is finally passed to the executor. If no template is specified the executor config specified in the package will be processed directly without template.
configScheme (optional) yaml
This is a JSONSCHEMA used to validate the executor config from the package prior to merging with the template
templateLibraries (optional) []ResourceReference
This is a list of resources whose content is used as additional stubs for the template processing.
credentials (optional) map[string]CredentialRequest
Here the executor may request the provisioning of some credentials with a dedicated name/purpose and structure. If specified it will be propagated to a using package. It this uses an own credentials section, this one will be filtered and checked for the the actual executor.
outputs (optional) map[string]OutputSpecification
This field can be used to describe the provided outputs of this executor. The OutputSpecification contains only the field description, so far. It is intended to be extended to contain further information to more formally describe the type of output.
image (development) object
Instead of an imageRef it is possible to directly specify an absolute image.
ATTENTION: this is intended for development purposes, ONLY. Do not use it for final component versions.
It has the field ref and the optional field digest.
Client Parameters # Common to all executors a parameter file can be provided by the caller. The package specification may provide a spiff template for this parameter file. It can be used, for example to provide useful defaults. The actually provided content is merged with this template.
To validate user configuration a JSON scheme can be provided. The user input is validated first against this scheme before the actual merge is done.
Credentials # Additionally credentials can be requested to be provided by a client. This is done with the credentials field. It is a map of credentials names and their meaning and/or handling.
It uses the following fields:
description string
This field should describe the purpose of the credential.
properties map[string]string
This field should describe the used credential fields
consumerId map[string]
This field can be used to optionally define a consumer id that should be set in the OCM support library, if used by the executor. At least the field type and one additional field must be set.
Credentials are provided in an ocm config file (see ocm configfile). It uses a memory credential repository with the name default to store the credentials under the given name. Additionally appropriate consumer ids will be propagated, if requested in the credentials request config.
Executor Image Contract # The executor image is called with the action as additional argument. It is expected that is defines a default entry point and a potentially empty list of standard arguments.
It is called with two arguments:
name of the action to execute
identity of the component version containing the package the executor is executed for.
This can be used to access the component descriptor to get access to further described resources in the executor config
The container used to execute the executor image gets prepared a standard filesystem structure used to provide all the executor inputs before the execution and reading provided executor outputs after the execution.
/ â””â”€â”€ toi â”œâ”€â”€ inputs â”‚Â â”œâ”€â”€ config config info from package specification â”‚Â â”œâ”€â”€ ocmrepo OCM filesystem repository containing the complete â”‚Â â”‚ component version of the package â”‚Â â””â”€â”€ parameters merged complete parameter file â”œâ”€â”€ outputs â”‚Â â”œâ”€â”€ \u0026lt;out\u003e any number of arbitrary output data provided â”‚Â â”‚ by executor â”‚Â â””â”€â”€ ... â””â”€â”€ run good practice: typical location for the executed command After processing it is possible to return named outputs. The name of an output must be a filename. The executor section in the package specification maps those files to logical outputs in the outputs section.
\u0026lt;file name by executor\u003e -\u003e \u0026lt;logical output name\u003e Basically the output may contain any data, but is strongly recommended to use yaml or json files, only. This enables further formal processing by the TOI toolset.
Examples # executors: - actions: - install resourceRef: resource: name: installerimage config: level: info # parameterMapping: # optional spiff mapping of Package configuration to # .... # executor parameters outputs: test: bla credentials: target: description: kubeconfig for target kubernetes cluster consumerId: type: Kubernetes purpose: target configTemplate: parameters: username: admin password: (( \u0026amp;merge )) configScheme: type: object required: - parameters additionalProperties: false properties: parameters: type: object required: - password additionalProperties: false properties: username: type: string password: type: string See Also # ocm bootstrap componentversions	â€” bootstrap component version ocm bootstrap	â€” bootstrap components `}),e.add({id:44,href:"/docs/cli/transfer/",title:"transfer",description:"Usage # ocm transfer [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for transfer See Also # Sub Commands # ocm transfer artefacts	â€” transfer OCI artefacts ocm transfer commontransportarchive	â€” transfer transport archive ocm transfer componentarchive	â€” transfer component archive to some component repository ocm transfer componentversions	â€” transfer component version ",content:"Usage # ocm transfer [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for transfer See Also # Sub Commands # ocm transfer artefacts	â€” transfer OCI artefacts ocm transfer commontransportarchive	â€” transfer transport archive ocm transfer componentarchive	â€” transfer component archive to some component repository ocm transfer componentversions	â€” transfer component version "}),e.add({id:45,href:"/docs/cli/create/transportarchive/",title:"transportarchive",description:`Usage # ocm create transportarchive [\u0026lt;options\u0026gt;] \u0026lt;path\u0026gt; Description # Create a new empty OCM/OCI transport archive. This might be either a directory prepared to host artefact content or a tar/tgz file.
Options # -f, --force remove existing content -h, --help help for transportarchive -t, --type string archive format (default \u0026quot;directory\u0026quot;) See Also # ocm create	â€” Create transport or component archive `,content:`Usage # ocm create transportarchive [\u0026lt;options\u0026gt;] \u0026lt;path\u0026gt; Description # Create a new empty OCM/OCI transport archive. This might be either a directory prepared to host artefact content or a tar/tgz file.
Options # -f, --force remove existing content -h, --help help for transportarchive -t, --type string archive format (default \u0026quot;directory\u0026quot;) See Also # ocm create	â€” Create transport or component archive `}),e.add({id:46,href:"/docs/cli/verify/",title:"verify",description:"Usage # ocm verify [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for verify See Also # Sub Commands # ocm verify componentversions	â€” Verify signature of component version ",content:"Usage # ocm verify [\u0026lt;options\u0026gt;] \u0026lt;sub command\u0026gt; ... Options # -h, --help help for verify See Also # Sub Commands # ocm verify componentversions	â€” Verify signature of component version "}),e.add({id:47,href:"/docs/cli/show/versions/",title:"versions",description:"Usage # ocm show versions [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;version pattern\u0026gt;} Description # Match versions of a component against some patterns. If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax \u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references: [\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications",content:`Usage # ocm show versions [\u0026lt;options\u0026gt;] \u0026lt;component\u0026gt; {\u0026lt;version pattern\u0026gt;} Description # Match versions of a component against some patterns.
If the \u0026ndash;repo option is specified, the given names are interpreted relative to the specified repository using the syntax
\u0026lt;component\u003e[:\u0026lt;version\u003e] If no \u0026ndash;repo option is specified the given names are interpreted as located OCM component version references:
[\u0026lt;repo type\u003e::]\u0026lt;host\u003e[:\u0026lt;port\u003e][/\u0026lt;base path\u003e]//\u0026lt;component\u003e[:\u0026lt;version\u003e] Additionally there is a variant to denote common transport archives and general repository specifications
[\u0026lt;repo type\u003e::]\u0026lt;filepath\u003e|\u0026lt;spec json\u003e[//\u0026lt;component\u003e[:\u0026lt;version\u003e]] The \u0026ndash;repo option takes an OCM repository specification:
[\u0026lt;repo type\u003e::]\u0026lt;configured name\u003e|\u0026lt;file path\u003e|\u0026lt;spec json\u003e For the Common Transport Format the types directory, tar or tgz is possible.
Using the JSON variant any repository type supported by the linked library can be used:
Dedicated OCM repository types:
ComponentArchive OCI Repository types (using standard component repository to OCI mapping):
ArtefactSet CommonTransportFormat DockerDaemon Empty OCIRegistry oci ociRegistry Options # -h, --help help for versions -l, --latest show only latest version -r, --repo string repository name or spec -s, --semantic show semantic version Examples # \$ ocm show versions ghcr.io/mandelsoft/cnudie//github.com/mandelsoft/playground See Also # ocm show	â€” Show tags or versions `}),e.add({id:48,href:"/docs/",title:"Docs",description:"Docs OCM.",content:`Get started # There are two main ways to get started with Doks:
Tutorial # `}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()